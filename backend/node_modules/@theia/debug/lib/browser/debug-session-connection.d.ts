import { DebugProtocol } from '@vscode/debugprotocol';
import { Deferred } from '@theia/core/lib/common/promise-util';
import { Event, Emitter, DisposableCollection, Disposable, MaybePromise } from '@theia/core';
import { OutputChannel } from '@theia/output/lib/browser/output-channel';
import { DebugChannel } from '../common/debug-service';
export declare type DebugRequestHandler = (request: DebugProtocol.Request) => MaybePromise<any>;
export interface DebugRequestTypes {
    'attach': [DebugProtocol.AttachRequestArguments, DebugProtocol.AttachResponse];
    'breakpointLocations': [DebugProtocol.BreakpointLocationsArguments, DebugProtocol.BreakpointLocationsResponse];
    'cancel': [DebugProtocol.CancelArguments, DebugProtocol.CancelResponse];
    'completions': [DebugProtocol.CompletionsArguments, DebugProtocol.CompletionsResponse];
    'configurationDone': [DebugProtocol.ConfigurationDoneArguments, DebugProtocol.ConfigurationDoneResponse];
    'continue': [DebugProtocol.ContinueArguments, DebugProtocol.ContinueResponse];
    'dataBreakpointInfo': [DebugProtocol.DataBreakpointInfoArguments, DebugProtocol.DataBreakpointInfoResponse];
    'disassemble': [DebugProtocol.DisassembleArguments, DebugProtocol.DisassembleResponse];
    'disconnect': [DebugProtocol.DisconnectArguments, DebugProtocol.DisconnectResponse];
    'evaluate': [DebugProtocol.EvaluateArguments, DebugProtocol.EvaluateResponse];
    'exceptionInfo': [DebugProtocol.ExceptionInfoArguments, DebugProtocol.ExceptionInfoResponse];
    'goto': [DebugProtocol.GotoArguments, DebugProtocol.GotoResponse];
    'gotoTargets': [DebugProtocol.GotoTargetsArguments, DebugProtocol.GotoTargetsResponse];
    'initialize': [DebugProtocol.InitializeRequestArguments, DebugProtocol.InitializeResponse];
    'launch': [DebugProtocol.LaunchRequestArguments, DebugProtocol.LaunchResponse];
    'loadedSources': [DebugProtocol.LoadedSourcesArguments, DebugProtocol.LoadedSourcesResponse];
    'modules': [DebugProtocol.ModulesArguments, DebugProtocol.ModulesResponse];
    'next': [DebugProtocol.NextArguments, DebugProtocol.NextResponse];
    'pause': [DebugProtocol.PauseArguments, DebugProtocol.PauseResponse];
    'readMemory': [DebugProtocol.ReadMemoryArguments, DebugProtocol.ReadMemoryResponse];
    'restart': [DebugProtocol.RestartArguments, DebugProtocol.RestartResponse];
    'restartFrame': [DebugProtocol.RestartFrameArguments, DebugProtocol.RestartFrameResponse];
    'reverseContinue': [DebugProtocol.ReverseContinueArguments, DebugProtocol.ReverseContinueResponse];
    'scopes': [DebugProtocol.ScopesArguments, DebugProtocol.ScopesResponse];
    'setBreakpoints': [DebugProtocol.SetBreakpointsArguments, DebugProtocol.SetBreakpointsResponse];
    'setDataBreakpoints': [DebugProtocol.SetDataBreakpointsArguments, DebugProtocol.SetDataBreakpointsResponse];
    'setExceptionBreakpoints': [DebugProtocol.SetExceptionBreakpointsArguments, DebugProtocol.SetExceptionBreakpointsResponse];
    'setExpression': [DebugProtocol.SetExpressionArguments, DebugProtocol.SetExpressionResponse];
    'setFunctionBreakpoints': [DebugProtocol.SetFunctionBreakpointsArguments, DebugProtocol.SetFunctionBreakpointsResponse];
    'setInstructionBreakpoints': [DebugProtocol.SetInstructionBreakpointsArguments, DebugProtocol.SetInstructionBreakpointsResponse];
    'setVariable': [DebugProtocol.SetVariableArguments, DebugProtocol.SetVariableResponse];
    'source': [DebugProtocol.SourceArguments, DebugProtocol.SourceResponse];
    'stackTrace': [DebugProtocol.StackTraceArguments, DebugProtocol.StackTraceResponse];
    'stepBack': [DebugProtocol.StepBackArguments, DebugProtocol.StepBackResponse];
    'stepIn': [DebugProtocol.StepInArguments, DebugProtocol.StepInResponse];
    'stepInTargets': [DebugProtocol.StepInTargetsArguments, DebugProtocol.StepInTargetsResponse];
    'stepOut': [DebugProtocol.StepOutArguments, DebugProtocol.StepOutResponse];
    'terminate': [DebugProtocol.TerminateArguments, DebugProtocol.TerminateResponse];
    'terminateThreads': [DebugProtocol.TerminateThreadsArguments, DebugProtocol.TerminateThreadsResponse];
    'threads': [{}, DebugProtocol.ThreadsResponse];
    'variables': [DebugProtocol.VariablesArguments, DebugProtocol.VariablesResponse];
    'writeMemory': [DebugProtocol.WriteMemoryArguments, DebugProtocol.WriteMemoryResponse];
}
export interface DebugEventTypes {
    'breakpoint': DebugProtocol.BreakpointEvent;
    'capabilities': DebugProtocol.CapabilitiesEvent;
    'continued': DebugProtocol.ContinuedEvent;
    'exited': DebugProtocol.ExitedEvent;
    'initialized': DebugProtocol.InitializedEvent;
    'invalidated': DebugProtocol.InvalidatedEvent;
    'loadedSource': DebugProtocol.LoadedSourceEvent;
    'module': DebugProtocol.ModuleEvent;
    'output': DebugProtocol.OutputEvent;
    'process': DebugProtocol.ProcessEvent;
    'progressEnd': DebugProtocol.ProgressEndEvent;
    'progressStart': DebugProtocol.ProgressStartEvent;
    'progressUpdate': DebugProtocol.ProgressUpdateEvent;
    'stopped': DebugProtocol.StoppedEvent;
    'terminated': DebugProtocol.TerminatedEvent;
    'thread': DebugProtocol.ThreadEvent;
}
export declare type DebugEventNames = keyof DebugEventTypes;
export declare namespace DebugEventTypes {
    function isStandardEvent(event: string): event is DebugEventNames;
}
export declare class DebugSessionConnection implements Disposable {
    readonly sessionId: string;
    protected readonly traceOutputChannel: OutputChannel | undefined;
    private sequence;
    protected readonly pendingRequests: Map<number, Deferred<DebugProtocol.Response>>;
    protected readonly connectionPromise: Promise<DebugChannel>;
    protected readonly requestHandlers: Map<string, DebugRequestHandler>;
    protected readonly onDidCustomEventEmitter: Emitter<DebugProtocol.Event>;
    readonly onDidCustomEvent: Event<DebugProtocol.Event>;
    protected readonly onDidCloseEmitter: Emitter<void>;
    readonly onDidClose: Event<void>;
    protected isClosed: boolean;
    protected readonly toDispose: DisposableCollection;
    constructor(sessionId: string, connectionFactory: (sessionId: string) => Promise<DebugChannel>, traceOutputChannel: OutputChannel | undefined);
    get disposed(): boolean;
    protected checkDisposed(): void;
    dispose(): void;
    protected createConnection(connectionFactory: (sessionId: string) => Promise<DebugChannel>): Promise<DebugChannel>;
    protected allThreadsContinued: boolean;
    sendRequest<K extends keyof DebugRequestTypes>(command: K, args: DebugRequestTypes[K][0], timeout?: number): Promise<DebugRequestTypes[K][1]>;
    sendCustomRequest<T extends DebugProtocol.Response>(command: string, args?: any): Promise<T>;
    protected cancelPendingRequests(): void;
    protected doSendRequest<K extends DebugProtocol.Response>(command: string, args?: any, timeout?: number): Promise<K>;
    protected send(message: DebugProtocol.ProtocolMessage): Promise<void>;
    protected handleMessage(data: string): void;
    protected handleResponse(response: DebugProtocol.Response): void;
    onRequest(command: string, handler: DebugRequestHandler): void;
    protected handleRequest(request: DebugProtocol.Request): Promise<void>;
    protected handleEvent(event: DebugProtocol.Event): void;
    protected readonly emitters: Map<string, Emitter<DebugProtocol.Event>>;
    on<K extends keyof DebugEventTypes>(kind: K, listener: (e: DebugEventTypes[K]) => any): Disposable;
    onEvent<K extends keyof DebugEventTypes>(kind: K): Event<DebugEventTypes[K]>;
    protected fire<K extends keyof DebugEventTypes>(kind: K, e: DebugEventTypes[K]): void;
    protected doFire<K extends keyof DebugEventTypes>(kind: K, e: DebugEventTypes[K]): void;
    protected getEmitter<K extends keyof DebugEventTypes>(kind: K): Emitter<DebugEventTypes[K]>;
    protected newEmitter(): Emitter<DebugProtocol.Event>;
    protected fireContinuedEvent(threadId: number, allThreadsContinued?: boolean): void;
}
//# sourceMappingURL=debug-session-connection.d.ts.map