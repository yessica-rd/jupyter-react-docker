"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandaloneThemeService = exports.HC_LIGHT_THEME_NAME = exports.HC_BLACK_THEME_NAME = exports.VS_DARK_THEME_NAME = exports.VS_LIGHT_THEME_NAME = void 0;
const dom = require("../../../base/browser/dom");
const browser_1 = require("../../../base/browser/browser");
const color_1 = require("../../../base/common/color");
const event_1 = require("../../../base/common/event");
const languages_1 = require("../../common/languages");
const encodedTokenAttributes_1 = require("../../common/encodedTokenAttributes");
const tokenization_1 = require("../../common/languages/supports/tokenization");
const themes_1 = require("../common/themes");
const platform_1 = require("../../../platform/registry/common/platform");
const colorRegistry_1 = require("../../../platform/theme/common/colorRegistry");
const themeService_1 = require("../../../platform/theme/common/themeService");
const lifecycle_1 = require("../../../base/common/lifecycle");
const theme_1 = require("../../../platform/theme/common/theme");
const iconsStyleSheet_1 = require("../../../platform/theme/browser/iconsStyleSheet");
exports.VS_LIGHT_THEME_NAME = 'vs';
exports.VS_DARK_THEME_NAME = 'vs-dark';
exports.HC_BLACK_THEME_NAME = 'hc-black';
exports.HC_LIGHT_THEME_NAME = 'hc-light';
const colorRegistry = platform_1.Registry.as(colorRegistry_1.Extensions.ColorContribution);
const themingRegistry = platform_1.Registry.as(themeService_1.Extensions.ThemingContribution);
class StandaloneTheme {
    constructor(name, standaloneThemeData) {
        this.semanticHighlighting = false;
        this.themeData = standaloneThemeData;
        const base = standaloneThemeData.base;
        if (name.length > 0) {
            if (isBuiltinTheme(name)) {
                this.id = name;
            }
            else {
                this.id = base + ' ' + name;
            }
            this.themeName = name;
        }
        else {
            this.id = base;
            this.themeName = base;
        }
        this.colors = null;
        this.defaultColors = Object.create(null);
        this._tokenTheme = null;
    }
    get label() {
        return this.themeName;
    }
    get base() {
        return this.themeData.base;
    }
    notifyBaseUpdated() {
        if (this.themeData.inherit) {
            this.colors = null;
            this._tokenTheme = null;
        }
    }
    getColors() {
        if (!this.colors) {
            const colors = new Map();
            for (const id in this.themeData.colors) {
                colors.set(id, color_1.Color.fromHex(this.themeData.colors[id]));
            }
            if (this.themeData.inherit) {
                const baseData = getBuiltinRules(this.themeData.base);
                for (const id in baseData.colors) {
                    if (!colors.has(id)) {
                        colors.set(id, color_1.Color.fromHex(baseData.colors[id]));
                    }
                }
            }
            this.colors = colors;
        }
        return this.colors;
    }
    getColor(colorId, useDefault) {
        const color = this.getColors().get(colorId);
        if (color) {
            return color;
        }
        if (useDefault !== false) {
            return this.getDefault(colorId);
        }
        return undefined;
    }
    getDefault(colorId) {
        let color = this.defaultColors[colorId];
        if (color) {
            return color;
        }
        color = colorRegistry.resolveDefaultColor(colorId, this);
        this.defaultColors[colorId] = color;
        return color;
    }
    defines(colorId) {
        return Object.prototype.hasOwnProperty.call(this.getColors(), colorId);
    }
    get type() {
        switch (this.base) {
            case exports.VS_LIGHT_THEME_NAME: return theme_1.ColorScheme.LIGHT;
            case exports.HC_BLACK_THEME_NAME: return theme_1.ColorScheme.HIGH_CONTRAST_DARK;
            case exports.HC_LIGHT_THEME_NAME: return theme_1.ColorScheme.HIGH_CONTRAST_LIGHT;
            default: return theme_1.ColorScheme.DARK;
        }
    }
    get tokenTheme() {
        if (!this._tokenTheme) {
            let rules = [];
            let encodedTokensColors = [];
            if (this.themeData.inherit) {
                const baseData = getBuiltinRules(this.themeData.base);
                rules = baseData.rules;
                if (baseData.encodedTokensColors) {
                    encodedTokensColors = baseData.encodedTokensColors;
                }
            }
            // Pick up default colors from `editor.foreground` and `editor.background` if available
            const editorForeground = this.themeData.colors['editor.foreground'];
            const editorBackground = this.themeData.colors['editor.background'];
            if (editorForeground || editorBackground) {
                const rule = { token: '' };
                if (editorForeground) {
                    rule.foreground = editorForeground;
                }
                if (editorBackground) {
                    rule.background = editorBackground;
                }
                rules.push(rule);
            }
            rules = rules.concat(this.themeData.rules);
            if (this.themeData.encodedTokensColors) {
                encodedTokensColors = this.themeData.encodedTokensColors;
            }
            this._tokenTheme = tokenization_1.TokenTheme.createFromRawTokenTheme(rules, encodedTokensColors);
        }
        return this._tokenTheme;
    }
    getTokenStyleMetadata(type, modifiers, modelLanguage) {
        // use theme rules match
        const style = this.tokenTheme._match([type].concat(modifiers).join('.'));
        const metadata = style.metadata;
        const foreground = encodedTokenAttributes_1.TokenMetadata.getForeground(metadata);
        const fontStyle = encodedTokenAttributes_1.TokenMetadata.getFontStyle(metadata);
        return {
            foreground: foreground,
            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),
            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),
            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),
            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */)
        };
    }
    get tokenColorMap() {
        return [];
    }
}
function isBuiltinTheme(themeName) {
    return (themeName === exports.VS_LIGHT_THEME_NAME
        || themeName === exports.VS_DARK_THEME_NAME
        || themeName === exports.HC_BLACK_THEME_NAME
        || themeName === exports.HC_LIGHT_THEME_NAME);
}
function getBuiltinRules(builtinTheme) {
    switch (builtinTheme) {
        case exports.VS_LIGHT_THEME_NAME:
            return themes_1.vs;
        case exports.VS_DARK_THEME_NAME:
            return themes_1.vs_dark;
        case exports.HC_BLACK_THEME_NAME:
            return themes_1.hc_black;
        case exports.HC_LIGHT_THEME_NAME:
            return themes_1.hc_light;
    }
}
function newBuiltInTheme(builtinTheme) {
    const themeData = getBuiltinRules(builtinTheme);
    return new StandaloneTheme(builtinTheme, themeData);
}
class StandaloneThemeService extends lifecycle_1.Disposable {
    constructor() {
        super();
        this._onColorThemeChange = this._register(new event_1.Emitter());
        this.onDidColorThemeChange = this._onColorThemeChange.event;
        this._onFileIconThemeChange = this._register(new event_1.Emitter());
        this.onDidFileIconThemeChange = this._onFileIconThemeChange.event;
        this._onProductIconThemeChange = this._register(new event_1.Emitter());
        this.onDidProductIconThemeChange = this._onProductIconThemeChange.event;
        this._environment = Object.create(null);
        this._builtInProductIconTheme = new iconsStyleSheet_1.UnthemedProductIconTheme();
        this._autoDetectHighContrast = true;
        this._knownThemes = new Map();
        this._knownThemes.set(exports.VS_LIGHT_THEME_NAME, newBuiltInTheme(exports.VS_LIGHT_THEME_NAME));
        this._knownThemes.set(exports.VS_DARK_THEME_NAME, newBuiltInTheme(exports.VS_DARK_THEME_NAME));
        this._knownThemes.set(exports.HC_BLACK_THEME_NAME, newBuiltInTheme(exports.HC_BLACK_THEME_NAME));
        this._knownThemes.set(exports.HC_LIGHT_THEME_NAME, newBuiltInTheme(exports.HC_LIGHT_THEME_NAME));
        const iconsStyleSheet = (0, iconsStyleSheet_1.getIconsStyleSheet)(this);
        this._codiconCSS = iconsStyleSheet.getCSS();
        this._themeCSS = '';
        this._allCSS = `${this._codiconCSS}\n${this._themeCSS}`;
        this._globalStyleElement = null;
        this._styleElements = [];
        this._colorMapOverride = null;
        this.setTheme(exports.VS_LIGHT_THEME_NAME);
        this._onOSSchemeChanged();
        iconsStyleSheet.onDidChange(() => {
            this._codiconCSS = iconsStyleSheet.getCSS();
            this._updateCSS();
        });
        (0, browser_1.addMatchMediaChangeListener)('(forced-colors: active)', () => {
            this._onOSSchemeChanged();
        });
    }
    registerEditorContainer(domNode) {
        if (dom.isInShadowDOM(domNode)) {
            return this._registerShadowDomContainer(domNode);
        }
        return this._registerRegularEditorContainer();
    }
    _registerRegularEditorContainer() {
        if (!this._globalStyleElement) {
            this._globalStyleElement = dom.createStyleSheet();
            this._globalStyleElement.className = 'monaco-colors';
            this._globalStyleElement.textContent = this._allCSS;
            this._styleElements.push(this._globalStyleElement);
        }
        return lifecycle_1.Disposable.None;
    }
    _registerShadowDomContainer(domNode) {
        const styleElement = dom.createStyleSheet(domNode);
        styleElement.className = 'monaco-colors';
        styleElement.textContent = this._allCSS;
        this._styleElements.push(styleElement);
        return {
            dispose: () => {
                for (let i = 0; i < this._styleElements.length; i++) {
                    if (this._styleElements[i] === styleElement) {
                        this._styleElements.splice(i, 1);
                        return;
                    }
                }
            }
        };
    }
    defineTheme(themeName, themeData) {
        if (!/^[a-z0-9\-]+$/i.test(themeName)) {
            throw new Error('Illegal theme name!');
        }
        if (!isBuiltinTheme(themeData.base) && !isBuiltinTheme(themeName)) {
            throw new Error('Illegal theme base!');
        }
        // set or replace theme
        this._knownThemes.set(themeName, new StandaloneTheme(themeName, themeData));
        if (isBuiltinTheme(themeName)) {
            this._knownThemes.forEach(theme => {
                if (theme.base === themeName) {
                    theme.notifyBaseUpdated();
                }
            });
        }
        if (this._theme.themeName === themeName) {
            this.setTheme(themeName); // refresh theme
        }
    }
    getColorTheme() {
        return this._theme;
    }
    setColorMapOverride(colorMapOverride) {
        this._colorMapOverride = colorMapOverride;
        this._updateThemeOrColorMap();
    }
    setTheme(themeName) {
        let theme;
        if (this._knownThemes.has(themeName)) {
            theme = this._knownThemes.get(themeName);
        }
        else {
            theme = this._knownThemes.get(exports.VS_LIGHT_THEME_NAME);
        }
        this._updateActualTheme(theme);
    }
    _updateActualTheme(desiredTheme) {
        if (!desiredTheme || this._theme === desiredTheme) {
            // Nothing to do
            return;
        }
        this._theme = desiredTheme;
        this._updateThemeOrColorMap();
    }
    _onOSSchemeChanged() {
        if (this._autoDetectHighContrast) {
            const wantsHighContrast = window.matchMedia(`(forced-colors: active)`).matches;
            if (wantsHighContrast !== (0, theme_1.isHighContrast)(this._theme.type)) {
                // switch to high contrast or non-high contrast but stick to dark or light
                let newThemeName;
                if ((0, theme_1.isDark)(this._theme.type)) {
                    newThemeName = wantsHighContrast ? exports.HC_BLACK_THEME_NAME : exports.VS_DARK_THEME_NAME;
                }
                else {
                    newThemeName = wantsHighContrast ? exports.HC_LIGHT_THEME_NAME : exports.VS_LIGHT_THEME_NAME;
                }
                this._updateActualTheme(this._knownThemes.get(newThemeName));
            }
        }
    }
    setAutoDetectHighContrast(autoDetectHighContrast) {
        this._autoDetectHighContrast = autoDetectHighContrast;
        this._onOSSchemeChanged();
    }
    _updateThemeOrColorMap() {
        const cssRules = [];
        const hasRule = {};
        const ruleCollector = {
            addRule: (rule) => {
                if (!hasRule[rule]) {
                    cssRules.push(rule);
                    hasRule[rule] = true;
                }
            }
        };
        themingRegistry.getThemingParticipants().forEach(p => p(this._theme, ruleCollector, this._environment));
        const colorVariables = [];
        for (const item of colorRegistry.getColors()) {
            const color = this._theme.getColor(item.id, true);
            if (color) {
                colorVariables.push(`${(0, colorRegistry_1.asCssVariableName)(item.id)}: ${color.toString()};`);
            }
        }
        ruleCollector.addRule(`.monaco-editor { ${colorVariables.join('\n')} }`);
        const colorMap = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
        ruleCollector.addRule((0, tokenization_1.generateTokensCSSForColorMap)(colorMap));
        this._themeCSS = cssRules.join('\n');
        this._updateCSS();
        languages_1.TokenizationRegistry.setColorMap(colorMap);
        this._onColorThemeChange.fire(this._theme);
    }
    _updateCSS() {
        this._allCSS = `${this._codiconCSS}\n${this._themeCSS}`;
        this._styleElements.forEach(styleElement => styleElement.textContent = this._allCSS);
    }
    getFileIconTheme() {
        return {
            hasFileIcons: false,
            hasFolderIcons: false,
            hidesExplorerArrows: false
        };
    }
    getProductIconTheme() {
        return this._builtInProductIconTheme;
    }
}
exports.StandaloneThemeService = StandaloneThemeService;
//# sourceMappingURL=standaloneThemeService.js.map